import time
import os
import sys
from colorama import Fore, Style
from tests.utils import timeout, get_wasm_execution_time, get_wasm_instruction_count
from utils import config
from utils.self_compiler import run_wasm
from utils.self_lexer_debug import generate_ascii
from utils.wasm_tools import wasm_to_file
from utils.utils import get_x0_value


def test_self_compiler(test_file, expected_output):
    """
    Test the self compiler by using the precompiled WASM self compiler to compile and execute a WHILE/EWHILE file.

    This function tests the self-hosted compiler pipeline by performing the following steps:
    1. Uses the precompiled self compiler WASM from bootstrapping iteration 3
    2. Generates ASCII input representation of the test file
    3. Runs the precompiled WASM compiler with the test file as input to generate WASM output
    4. Extracts and saves the generated WASM to a file
    5. Executes the generated WASM and verifies the output
    6. Reports detailed metrics including load time, execution time, and instruction count

    A timeout is applied to both the compilation and execution phases (changeable via ./utils/config.py).

    Args:
        test_file (str): Path to the test file (.ewhile or .while)
        expected_output (str): Expected output value from the program

    Returns:
        tuple: (success, correct, wasm_file, compile_time, run_time, x0_value, wasm_instructions)
            - success (bool): Whether compilation and execution were successful
            - correct (bool): Whether the output matches the expected output
            - wasm_file (str): Path to the generated WASM file
            - compile_time (float): Time taken to load the precompiled compiler in seconds
            - run_time (float): Time taken for execution in seconds
            - x0_value (str): Output value from the program (x0 register)
            - wasm_instructions (int): Number of WASM instructions in the generated file
    """
    print(f"\n{Fore.YELLOW}{Style.BRIGHT}▶ 3. Testing Self Compiler{Style.RESET_ALL}")

    try:
        # Use precompiled self compiler from bootstrapping iteration 3
        total_start = time.time()

        wasm_filepath_compiler = (
            sys.path[0]
            + "/bootstrapping/self_compiler_iteration_3_with_optimisation.wasm"
        )

        # Generate ASCII input for the self compiler
        inputs_self = generate_ascii(test_file)

        # Run self compiler with suppressed output and timeout
        @timeout(config.self_compiler_timeout)
        def run_self_compiler(filepath, inputs):
            # Use the suppress_output parameter to completely suppress output
            return run_wasm(filepath, inputs, suppress_output=True)

        # Measure total time (including WASM loading)
        total_start = time.time()
        self_compiler_output = run_self_compiler(wasm_filepath_compiler, inputs_self)
        total_end = time.time()
        total_time = total_end - total_start

        # Extract pure compilation time from WASM runner output
        pure_compile_time = get_wasm_execution_time(self_compiler_output)
        if pure_compile_time is None:
            print(
                f"  {Fore.RED}\u2717 Could not get WASM execution time from runner output{Style.RESET_ALL}"
            )
            pure_compile_time = 0

        # Extract and save the WASM generated by self compiler
        # Temporarily redirect stdout to suppress 'PROCESSING WASM OUTPUT' messages
        original_stdout = sys.stdout
        sys.stdout = open(os.devnull, "w")
        try:
            self_wasm_file = wasm_to_file(self_compiler_output)
        finally:
            sys.stdout.close()
            sys.stdout = original_stdout

        # Count WASM instructions generated by self compiler using wasm-stats
        self_wasm_instructions = get_wasm_instruction_count(self_wasm_file)

        # Run the WASM generated by self compiler with timeout
        @timeout(10)
        def run_self_output(filepath):
            # Use the suppress_output parameter to completely suppress output
            return run_wasm(filepath, [], suppress_output=True)

        # Run the WASM file and extract execution time
        self_output = run_self_output(self_wasm_file)

        # Extract execution time reported directly from the WASM runner
        self_run_time = get_wasm_execution_time(self_output)
        if self_run_time is None:
            print(
                f"  {Fore.RED}\u2717 Could not get WASM execution time from runner output{Style.RESET_ALL}"
            )
            self_run_time = 0

        # Extract output and check correctness
        self_x0_value = str(get_x0_value(self_output))
        self_correct = self_x0_value == expected_output

        print(
            f"  {Fore.GREEN}✓{Style.RESET_ALL} Precompiled compiler load time: {Fore.GREEN}{total_time:.4f}s{Style.RESET_ALL}"
        )
        print(
            f"  {Fore.GREEN}✓{Style.RESET_ALL} Compile time: {Fore.GREEN}{pure_compile_time:.4f}s{Style.RESET_ALL}"
        )
        print(
            f"  {Fore.GREEN}✓{Style.RESET_ALL} WASM execution time: {Fore.GREEN}{self_run_time:.4f}s{Style.RESET_ALL}"
        )
        print(
            f"  {Fore.GREEN}✓{Style.RESET_ALL} WASM instructions: {Fore.CYAN}{self_wasm_instructions}{Style.RESET_ALL}"
        )
        result_color = Fore.GREEN if self_correct else Fore.RED
        result_symbol = "✓" if self_correct else "✗"
        print(
            f"  {result_color}{result_symbol}{Style.RESET_ALL} Result correct: {result_color}{self_correct}{Style.RESET_ALL} (Expected: {expected_output}, Got: {self_x0_value})"
        )

        return (
            True,
            self_correct,
            self_wasm_file,
            pure_compile_time,
            self_run_time,
            self_x0_value,
            self_wasm_instructions,
        )
    except TimeoutError as e:
        print(f"  {Fore.RED}✗ TIMEOUT: {str(e)}{Style.RESET_ALL}")
        return False, False, None, 0, 0, None, 0
    except Exception as e:
        print(f"  {Fore.RED}✗ ERROR in self compiler: {str(e)}{Style.RESET_ALL}")
        return False, False, None, 0, 0, None, 0
