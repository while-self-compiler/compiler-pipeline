const EXAMPLE_SCRIPTS = [
  "fib.while",
  "factorial.while",
  "self_compiler.while"
];
const COMPILERS = [
  {
    id: 'iteration-it1',
    label: 'IT1',
    tooltip: 'First compiler with optimisations (generated by minimal bootstrap-compiler).',
    file: 'self_compiler_iteration_1_with_optimisation.wasm'
  },
  {
    id: 'iteration-it2',
    label: 'IT2',
    tooltip: 'Second optimised compiler, after compiling its sourcecode with IT1.',
    file: 'self_compiler_iteration_2_with_optimisation.wasm'
  },
  {
    id: 'iteration-it3',
    label: 'IT3',
    tooltip: 'Third iteration, after compiling same sourcecode with IT2 (IT2 and IT3 are fully identical (fixpoint)).',
    file: 'self_compiler_iteration_3_with_optimisation.wasm'
  }
]

document.addEventListener("DOMContentLoaded", () => {
  const compileBtn = document.getElementById("open-run");
  //const codeEditor = document.getElementById("codeEditor");
  const outputArea = document.getElementById("outputArea");
  const select = document.getElementById("scriptSelect");
  const languageSelect = document.getElementById("languageSelect");
  const settingsBtn = document.getElementById("open-settings");
  const closeSettingsBtn = document.getElementById("close-settings");

  generateIterationRadios('iteration-container', COMPILERS, 'iteration-it1');

  let isUpdatingToolbar = false; // recursion guard
  function updateVariableToolbar(code) {
    if (isUpdatingToolbar) return;
    isUpdatingToolbar = true;
    try {
      const toolbar = document.getElementById('variable-toolbar');
      toolbar.innerHTML = '';

      const MAX_VARIABLES = 1000; // because of WASM limit
      const seen = new Set();

      const regex = /\bx(\d+)\b/g;
      let match;
      while ((match = regex.exec(code)) !== null) {
        const n = parseInt(match[1], 10);
        if (!isNaN(n) && n > 0) {
          seen.add(n);
        }
        if (seen.size >= MAX_VARIABLES) break;
      }

      if (seen.size === 0) {
        return;
      }

      const nums = Array.from(seen).sort((a, b) => a - b);

      for (let n of nums) {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.alignItems = 'center';

        const label = document.createElement('label');
        label.innerHTML = `n<sub>${n}</sub> =`;
        label.style.marginRight = '4px';

        const input = document.createElement('input');
        input.type = 'text';
        input.id = `n${n}`;
        input.name = `n${n}`;
        input.value = '0';

        wrapper.appendChild(label);
        wrapper.appendChild(input);
        toolbar.appendChild(wrapper);
      }

      if (regex.exec !== undefined && seen.size >= MAX_VARIABLES) {
        const note = document.createElement('div');
        note.style.marginTop = '10px';
        note.style.color = '#ff9800';
        note.textContent = `Only the first ${MAX_VARIABLES} distinct variables are shown. Note that the current self compiler implementation cannot handle more than 1000 variables (due to a WASM limitation). However, this could be circumvented by suitable approaches`;
        toolbar.appendChild(note);
      }
    } finally {
      isUpdatingToolbar = false;
    }
  }

  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  settingsBtn.addEventListener("click", () => {
    // hide the main content and show the settings
    document.getElementById("editor-container").style.display = "none";
    document.getElementById("settings-container").style.display = "block";
  });
  closeSettingsBtn.addEventListener("click", () => {
    // hide the settings and show the main content
    document.getElementById("editor-container").style.display = "block";
    document.getElementById("settings-container").style.display = "none";
  });

  const codeEditor = CodeMirror.fromTextArea(document.getElementById("codeEditor"), {
    mode: "text/x-while",
    theme: "material",
    lineNumbers: true,
    indentUnit: 2,
    tabSize: 2,
    lineWrapping: true
  });
  const debouncedUpdate = debounce(() => {
    const code = codeEditor.getValue();
    updateVariableToolbar(code);
  }, 300);
  codeEditor.on("change", debouncedUpdate);
  EXAMPLE_SCRIPTS.forEach(file => {
    const opt = document.createElement("option");
    opt.value = file;
    opt.textContent = file;
    select.appendChild(opt);
  });

  function getModeFromFilename(filename) {
    if (filename.endsWith(".while")) return "text/x-while";
    if (filename.endsWith(".ewhile")) return "text/x-ewhile";
    return "text/x-while"; // Default mode
  }

  function filterScriptsByMode(mode) {
    select.innerHTML = `<option value="">Select a script</option>`;

    const extension = mode === "text/x-while" ? ".while" : ".ewhile";

    EXAMPLE_SCRIPTS.forEach(file => {
      if (file.endsWith(extension)) {
        const opt = document.createElement("option");
        opt.value = file;
        opt.textContent = file;
        select.appendChild(opt);
      }
    });
  }

  // filterScriptsByMode(languageSelect.value);
  
  select.addEventListener("change", async () => {
    const file = select.value;
    if (!file) return;

    try {
      const res = await fetch(`example_scripts/${file}`);
      if (!res.ok) throw new Error(`The file ${file} could not be loaded: ${res.status}`);
      const content = await res.text();

      codeEditor.setValue(content);

      const detectedMode = getModeFromFilename(file);

      codeEditor.setOption("mode", detectedMode);

      // languageSelect.value = detectedMode;

      outputArea.textContent = `Script loaded: ${file}`;
      outputArea.style.color = "#4caf50";

    } catch (err) {
      //outputArea.textContent = `Error: ${err.message}`;
      //outputArea.style.color = "#ff6b6b";
    }
  });

  compileBtn.addEventListener("click", async () => {
    const steps = [
      { id: 'run', label: 'Prepare and encode input', status: 'pending' },
      { id: 'selfCompile', label: 'Load self compiler instance ' + getSelectedCompiler().name, status: 'pending' },
      { id: 'execute', label: 'Compile with self compiler', status: 'pending' }
      { id: 'executeCompiledFile', label: 'Run the compiled input', status: 'pending' }
    ];
    renderPipelineStatus(steps);

    steps.forEach(step => {
      startTimer(step.id);
    });

    const code = codeEditor.getValue().trim();

    if (!code) {
      outputArea.textContent =
        "Error: No code to compile. Please enter some WHILE code.";
      outputArea.style.color = "#ff6b6b";
      updatePipelineStep('run', 'error');
      updatePipelineStep('selfCompile', 'error');
      updatePipelineStep('execute', 'error');
      updatePipelineStep('executeCompiledFile', 'error');
      return;
    }

    try {
      const uppercaseCode = code.toUpperCase();
      const hexString = textToAsciiHex(code);
      const asciiResult = textToAsciiBigInt(code);
      const asciiBigInt = asciiResult.bigint;
      const byteCount = asciiResult.byteCount;

      outputArea.textContent = 
        "Compiling WHILE code...\n\n" +
        "Original code:\n" + code + "\n\n" +
        "Uppercase code:\n" + truncateString(uppercaseCode) + "\n\n" +
        "ASCII Hex representation:\n" + truncateString(hexString) + "\n\n" +
        "ASCII BigInt:\n" + truncateString(asciiBigInt.toString()) + "\n\n" +
        "Byte count:\n" + byteCount + "\n\n" +
        "Running selected self compiler";
      outputArea.style.color = "#2196f3";

      console.log("WHILE code converted to ASCII hex:", hexString);
      console.log("WHILE code as BigInt:", asciiBigInt);
      console.log("Byte count:", byteCount);
  
      const parameters = {
        "n1": asciiBigInt,  // ASCII representation as BigInt
        "n2": BigInt(byteCount)  // Number of bytes as BigInt
      };

      updatePipelineStep('run', 'success');

      console.log(`Running self_compiler.wasm with n1=${asciiBigInt}, n2=${byteCount}`);

      const selectedCompiler = getSelectedCompiler();
      const response = await fetch(`content/${selectedCompiler.file}`);
      
      if (!response.ok) {
        throw new Error(`Failed to load self_compiler.wasm: ${response.status}`);
      }

      updatePipelineStep('selfCompile', 'success');

      const wasmBytes = await response.arrayBuffer();

      let result = "";
      try {
        result = await runWasmInWorker(wasmBytes, parameters);
        updatePipelineStep('execute', 'success');
      } catch (err) {
        updatePipelineStep('execute', 'error');
        throw err;  
      }      
      const resultBigInt = BigInt(result);
      let hexResult = resultBigInt.toString(16);
      
      if (hexResult.length % 2 !== 0) {
        hexResult = "0" + hexResult;
      }
      
      const wasmHex = "00" + hexResult;
      updatePipelineStep('execute', 'success');
      console.log(`Self compiler result: ${result}`);
      console.log(`Hex representation: ${hexResult}`);
      console.log(`WASM hex with prefix: ${wasmHex}`);
      
      const wasmBytesFromResult = new Uint8Array(wasmHex.length / 2);
      for (let i = 0; i < wasmHex.length; i += 2) {
        wasmBytesFromResult[i / 2] = parseInt(wasmHex.substr(i, 2), 16);
      }
      
      outputArea.textContent = 
        "Compilation completed!" + `(${selectedCompiler.label} with ${selectedCompiler.file} has been used)`  + " Running compiled WASM...\n\n" +
        "Original code:\n" + code + "\n\n" +
        "Self compiler result (decimal):\n" + truncateString(result.toString()) + "\n\n" +
        "Self compiler result (hex):\n" + truncateString(hexResult) + "\n\n" +
        "WASM bytes (with 00 prefix):\n" + truncateString(wasmHex) + "\n\n" +
        "Executing compiled WASM...";
      outputArea.style.color = "#2196f3";

      const toolbar = document.getElementById('variable-toolbar');
      const inputs = Array.from(toolbar.querySelectorAll('input[id^="n"]'))
        .filter(input => /^n[1-9]\d*$/.test(input.id)); 

      const parametersRuntime = {};
      inputs.forEach(input => {
        const key = input.id;
        let val = input.value.trim();
        try {
          val = val === '' ? 0n : BigInt(val);
        } catch {
          val = 0n;
        }
        parametersRuntime[key] = val;
      });
      
      const finalResult = await runWasm(wasmBytesFromResult.buffer, parametersRuntime);
      updatePipelineStep('executeCompiledFile', 'success');
      outputArea.textContent = 
        "Full compilation and execution completed!" + `(${selectedCompiler.label} with ${selectedCompiler.file} has been used)`  + "\n\n" +
        "Self compiler output (decimal):\n" + result.toString() + "\n\n" +
        "Self compiler output (hex):\n" + hexResult  + "\n\n" +
        "WASM bytes:\n" + wasmHex  + "\n\n"

      const outputWatCheckbox = document.getElementById('output-wat');
      const printWat = outputWatCheckbox && outputWatCheckbox.checked;
      if(printWat) {
        const watCode = await generateWatCode(wasmBytes);
        const newWindow = window.open();
        newWindow.document.write('<pre>' + escapeHtml(watCode) + '</pre>');
        newWindow.document.title = 'WAT Code Output';
        newWindow.document.close();
      }

      outputArea.style.color = "#4caf50";

      document.getElementById("resultbar").innerHTML = "";
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';

      const label = document.createElement('label');
      label.innerHTML = `x<sub>0</sub> = ${finalResult.toString()}`;
      label.style.marginRight = '4px';

      wrapper.appendChild(label);
      document.getElementById("resultbar").appendChild(wrapper);
    } catch (error) {
      outputArea.textContent = 
        "Compilation failed!"//\n\n" +
        // "Original code:\n" + code + "\n\n" +
        //"Error:\n" + error.message;
      outputArea.style.color = "#ff6b6b";
      console.error("Compilation error:", error);
    }

    compileBtn.classList.add("clicked");
    setTimeout(() => {
      compileBtn.classList.remove("clicked");
    }, 200);
  });
/*
  codeEditor.addEventListener("input", () => {
    codeEditor.style.height = "auto";
    codeEditor.style.height = codeEditor.scrollHeight + "px";
  });*/
  /*
  languageSelect.addEventListener("change", (e) => {
    console.log("Language changed to:", e.target.value);
    const mode = e.target.value;  
    codeEditor.setOption("mode", mode);
    filterScriptsByMode(mode);
    codeEditor.setValue("");
    outputArea.textContent = "";
  });*/
});

function truncateString(str, maxLength = 50) {
  if (str.length <= maxLength) {
    return str;
  }
  return str.substring(0, maxLength) + "...";
}

const stepTimers = {}; // { startTime: number, intervalId: number }

function renderPipelineStatus(steps) {
  const container = document.getElementById("pipeline-status");
  container.innerHTML = ''; // Clear previous

  steps.forEach(step => {
    const div = document.createElement("div");
      div.className = `pipeline-step ${step.status}`;
      div.id = `pipeline-${step.id}`;

      // Label-Text
      const labelSpan = document.createElement("span");
      labelSpan.textContent = step.label;
      div.appendChild(labelSpan);

      // Timer-Span, initial 00:00.000
      const timerSpan = document.createElement("span");
      timerSpan.id = `timer-${step.id}`;
      timerSpan.style.marginLeft = '8px';
      timerSpan.style.fontFamily = 'monospace';
      timerSpan.style.fontSize = '0.9em';
      timerSpan.textContent = "00:00.000";
      div.appendChild(timerSpan);

      container.appendChild(div);
  });
}

function formatDuration(ms) {
  const totalMs = Math.max(0, ms);
  const minutes = Math.floor(totalMs / 60000);
  const seconds = Math.floor((totalMs % 60000) / 1000);
  const millis = Math.floor(totalMs % 1000);
  const pad = (n, width=2) => String(n).padStart(width, '0');
  const padMs = String(millis).padStart(3, '0');
  return `${pad(minutes)}:${pad(seconds)}.${padMs} min`;
}

function startTimer(id) {
  stopTimer(id);

  const span = document.getElementById(`timer-${id}`);
  if (!span) return;
  const startTime = performance.now();
  const intervalId = setInterval(() => {
    const elapsed = performance.now() - startTime;
    span.textContent = formatDuration(elapsed);
  }, 100); // update every 100ms

  stepTimers[id] = { startTime, intervalId };
}

function stopTimer(id) {
  const entry = stepTimers[id];
  if (!entry) return;
  clearInterval(entry.intervalId);
  const span = document.getElementById(`timer-${id}`);
  if (span) {
    const elapsed = performance.now() - entry.startTime;
    span.textContent = formatDuration(elapsed);
  }
  delete stepTimers[id];
}

function updatePipelineStep(id, status) {
  const step = document.getElementById(`pipeline-${id}`);
  if (step) {
    step.className = `pipeline-step ${status}`;
    if (status === 'success' || status === 'error') {
      stopTimer(id);
    }
  }
}

function runWasmInWorker(wasmBytes, parameters) {
  return new Promise((resolve, reject) => {
    const worker = new Worker("js/utils/wasm_worker.js"); 

    worker.onmessage = (e) => {
      const { success, result, error } = e.data;
      worker.terminate();

      if (success) {
        resolve(result);
      } else {
        reject(new Error(error));
      }
    };

    worker.onerror = (err) => {
      worker.terminate();
      reject(err);
    };

    worker.postMessage({ wasmBytes, parameters });
  });
}

function resetPipelineStatus(steps) {
  steps.forEach(id => updatePipelineStep(id, 'pending'));
}

function generateIterationRadios(containerId, iterations, checkedId) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error(`Container with id '${containerId}' not found`);
    return;
  }

  container.innerHTML = ''; // Clear existing content

  iterations.forEach(({ id, label, tooltip }) => {
    const div = document.createElement('div');

    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'iteration';
    input.id = id;
    input.value = label.toLowerCase();
    if (id === checkedId) input.checked = true;

    const inputLabel = document.createElement('label');
    inputLabel.htmlFor = id;
    inputLabel.textContent = label;

    const tooltipDiv = document.createElement('div');
    tooltipDiv.className = 'tooltip';

    const img = document.createElement('img');
    img.className = 'question-mark';
    img.id = `help-${id}`;
    img.src = 'img/question_icon.png';

    const span = document.createElement('span');
    span.className = 'tooltiptext';
    span.textContent = tooltip;

    tooltipDiv.appendChild(img);
    tooltipDiv.appendChild(span);

    div.appendChild(input);
    div.appendChild(inputLabel);
    div.appendChild(tooltipDiv);
    div.appendChild(document.createElement('br'));

    container.appendChild(div);
  });
}

function getSelectedCompiler() {
  const radios = document.querySelectorAll('input[name="iteration"]');
  let selected = COMPILERS[0]; // Default IT1
  radios.forEach(radio => {
    if (radio.checked) {
      selected = COMPILERS.find(c => c.label.toLowerCase() === radio.value);
    }
  });
  return selected;
}

async function generateWatCode(wasmBytes) {
  // Wabt laden
  const wabt = await WabtModule();

  // WASM-Bytes als Uint8Array annehmen
  try {
    const module = wabt.readWasm(wasmBytes, { readDebugNames: true });
    module.generateNames();
    module.applyNames();
    const wat = module.toText({ foldExprs: false, inlineExport: false });
    module.destroy();
    return wat;
  } catch (e) {
    console.error("Fehler beim Konvertieren von WASM zu WAT:", e);
    return "// Fehler beim Erzeugen von WAT-Code";
  }
}

function escapeHtml(text) {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}